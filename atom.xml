<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Terry’s Blog</title>
  
  <subtitle>Stay Hungry，Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-08T05:20:27.073Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Terry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>daemon 进程为什么要fork两次，与后台运行程序区别？</title>
    <link href="http://yoursite.com/2019/09/08/daemon-%E8%BF%9B%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81fork%E4%B8%A4%E6%AC%A1%EF%BC%8C%E4%B8%8E%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/09/08/daemon-进程为什么要fork两次，与后台运行程序区别？/</id>
    <published>2019-09-08T05:11:05.000Z</published>
    <updated>2019-09-08T05:20:27.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>daemon进程是后台守护进程<br>daemon函数存在的原因是因为控制终端由于某些原因（如断开终端链接）会发送一些信号的原因。而接收进程处理这些信号缺省动作会让进程退出。这些信号会由于终端上敲一些特殊按键而产生。</p></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int daemon(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if( pid != 0 ) exit(0);//parent</span><br><span class="line">    //first children</span><br><span class="line">    if(setsid() == -1)</span><br><span class="line">    &#123;</span><br><span class="line">       printf(&quot;setsid failed\n&quot;);</span><br><span class="line">       assert(0);</span><br><span class="line">       exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    umask(0);</span><br><span class="line">    pid = fork();</span><br><span class="line">    if( pid != 0) exit(0);</span><br><span class="line">    //second children </span><br><span class="line">    chdir (&quot;/&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 3; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close (i);</span><br><span class="line">    &#125;</span><br><span class="line">    int stdfd = open (&quot;/dev/null&quot;, O_RDWR);</span><br><span class="line">    dup2(stdfd, STDOUT_FILENO);</span><br><span class="line">    dup2(stdfd, STDERR_FILENO);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol><li><p>第一次fork 的作用 是让shell 认为本条命令已经终止，不用挂在终端输入上。还有一个作用是为后面setsid服务。<strong>setsid的调用者不能让进程组组长（group leader）.此时父进程是进程组长。</strong></p></li><li><p>setsid() 是本函数最重要的一个调用。它完成了daemon函数想要做的大部分事情。调用完整个函数。子进程是会话组长(sid==pid)，也是进程组组长(pgid == pid)，并且脱离了原来控制终端。到了这一步，基本上不管控制终端如何怎么样。新的进程都不会收到那些信号。</p></li><li><p>经过前面2个步骤，基本想要做的都做了。第2次fork不是必须的。也看到很多开源服务没有fork第二次。fork第二次主要目的是。防止进程再次打开一个控制终端。因为打开一个控制终端的前提条件是该进程必须是会话组长。再fork一次，子进程ID != sid（sid是进程父进程的sid）。所以也无法打开新的控制终端。</p></li><li><p>daemon目的就是防止终端产生的一些信号让进程退出。上面函数并没有直接调用signal函数去处理它。而是间接通过fork和setsid函数使用更少代码优雅处理。而被有些人误以为是僵死进程的原因需要这样处理。</p></li></ol><h1 id="守护进程与用-amp-结尾的后台运行程序有什么区别呢？"><a href="#守护进程与用-amp-结尾的后台运行程序有什么区别呢？" class="headerlink" title="守护进程与用&amp;结尾的后台运行程序有什么区别呢？"></a>守护进程与用&amp;结尾的后台运行程序有什么区别呢？</h1><p>最大的区别有几点：<br>1)守护进程已经完全脱离终端控制台了，而后台程序并未完全脱离终端，在终端未关闭前还是会往终端输出结果<br>2)守护进程在关闭终端控制台时不会受影响，而后台程序会随用户退出而停止，需要在以nohug xxx &amp; 格式运行才能避免影响<br>3)守护进程的会话组和当前目录，文件描述符都是独立的。后台运行只是终端进行了一次fork，让程序在后台执行，这些都没改变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;daemon进程是后台守护进程&lt;br&gt;daemon函数存在的原因是因为控制终端由于某些原因（如断开终端链接）会发送一些信号的原因。而接收进程处理这些信号缺省动作会让进程退出。这些信号会由于终端上敲一些特殊按键而产生。&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>git fork 别人的项目后再同步</title>
    <link href="http://yoursite.com/2019/09/08/git-fork-%E5%88%AB%E4%BA%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%86%8D%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2019/09/08/git-fork-别人的项目后再同步/</id>
    <published>2019-09-08T05:06:03.000Z</published>
    <updated>2019-09-08T05:20:11.840Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream  fork的原始git 地址</span><br><span class="line">git remote -v ;</span><br><span class="line">git fetch upstream;                    </span><br><span class="line">git merge upstream/master;</span><br><span class="line">git pull origin master;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><pre><code>git remote -v                               //可以查看 添加后的分支状态git fetch upstream                    //从原始仓库更新同步代码git merge upstream/master            //合并到本地代码git pull origin master   // 更新合并自己的远程仓库的代码git push                   //向自己远程仓库推送刚才同步源仓库后的代码</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发</title>
    <link href="http://yoursite.com/2019/09/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/09/08/敏捷开发/</id>
    <published>2019-09-08T05:04:46.000Z</published>
    <updated>2019-09-08T05:05:04.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="敏捷开发的定义"><a href="#敏捷开发的定义" class="headerlink" title="敏捷开发的定义"></a>敏捷开发的定义</h1><p>以<strong>用户的需求进化</strong>作为核心，采用迭代、循序渐进的方法进行软件开发。</p><p>换句话说就是把一个大的项目分为多个相互联系，但也可以独立运行的小项目（story？<br>），并分别完成，在这个过程中软件一直处于<strong>可使用</strong>的状态。</p><h1 id="应用场景和特点"><a href="#应用场景和特点" class="headerlink" title="应用场景和特点"></a>应用场景和特点</h1><p>在软件项目的构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。</p><h1 id="开发宣言"><a href="#开发宣言" class="headerlink" title="开发宣言"></a>开发宣言</h1><pre><code>个体和交互 胜过过程和工具可以工作的软件 胜过 面面俱到的文档客户合作  胜过 合同谈判响应变化 胜过 遵循计划</code></pre><p>注：虽然右项也有价值，但是我们认为左项具有更大的价值。</p><h1 id="开发原则"><a href="#开发原则" class="headerlink" title="开发原则"></a>开发原则</h1><ol><li>快速迭代</li><li>让测试人员和开发者参与需求讨论</li><li>编写可测试的需求文档<br> 开始就用“用户故事”（user story）的方法来编写需求文档。</li><li>多沟通，尽量减少文档</li><li>做好产品原型<br>建议使用草图和模型来阐明用户界面，并不是所有人都可以理解一份复杂的文档，但人人都会看图。</li><li>及早考虑测试。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;敏捷开发的定义&quot;&gt;&lt;a href=&quot;#敏捷开发的定义&quot; class=&quot;headerlink&quot; title=&quot;敏捷开发的定义&quot;&gt;&lt;/a&gt;敏捷开发的定义&lt;/h1&gt;&lt;p&gt;以&lt;strong&gt;用户的需求进化&lt;/strong&gt;作为核心，采用迭代、循序渐进的方法进行软件开发。&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>、释放命令</title>
    <link href="http://yoursite.com/2019/09/08/%E3%80%81%E9%87%8A%E6%94%BE%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/09/08/、释放命令/</id>
    <published>2019-09-08T05:03:41.000Z</published>
    <updated>2019-09-08T05:19:25.761Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">free -m  查看内存使用情况</span><br><span class="line"></span><br><span class="line">echo 1 &gt; /proc/sys/vm/drop_caches     // 释放页缓存</span><br><span class="line">echo 2 &gt; /proc/sys/vm/drop_caches     //释放dentries和inodes</span><br><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches     // 释放所有缓存</span><br><span class="line"></span><br><span class="line">到这里内存就释放完了，现在drop_caches中的值为1，如果现在想让操作系统重新分配内存，那么设置drop_caches的值为0即可：</span><br><span class="line"></span><br><span class="line">echo 0 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"></span><br><span class="line">free m</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>extren关键字</title>
    <link href="http://yoursite.com/2019/09/08/extren%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/09/08/extren关键字/</id>
    <published>2019-09-08T05:00:00.000Z</published>
    <updated>2019-09-08T05:20:18.528Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h1 id="首先-明白-这个单词-是什么意思？"><a href="#首先-明白-这个单词-是什么意思？" class="headerlink" title="首先 明白 这个单词 是什么意思？"></a>首先 明白 这个单词 是什么意思？</h1><p>Extern : 外部 的意思</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>置于 变量或者函数前，表示变量或者函数的定义在别的文件中，提示 编译器 遇到此变量和函数时，在其他模块中寻找其定义。</p><h1 id="作用-主要有两个"><a href="#作用-主要有两个" class="headerlink" title="作用  主要有两个"></a>作用  主要有两个</h1><p>第一个 ： 与 “C” 一起连用时，如 extern  “C” void fun（int a，int b）告诉编译器在编译fun 这个函数名的时候按照C的规则去编译。而不是C++</p><p>第二个： 当extern 不与C 一起修饰变量或函数时。如在头文件中：externa int g_int ;作用是：   声明函数或者全局变量 的作用范围的关键字，声明的函数或者变量可以在本模块或者其他模块中使用。记住，它 是<strong>一个声明不是定义</strong>。</p><p>extern用在变量声明中常常有这样一个作用，你在<em>.c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在</em>.h中并用extern来声明。</p><h1 id="具体解释及示例"><a href="#具体解释及示例" class="headerlink" title=".具体解释及示例"></a>.具体解释及示例</h1><p>2.1.extern的变量和函数声明<br>extern用于修饰变量或函数，用于声明当前变量或函数可以在本模块或者其他模块中使用。不过要记住的是extern只是声明，而不是定义，也就是说extern并不分配空间。而这个查找的过程是在连接的过程中进行的，因此编译阶段虽然找不到该变量或函数，但是也不会报错。下面用三个例子来看一看。</p><p>（1）无extern声明，有变量定义。</p><pre><code>stdafx.cpp#include &quot;stdafx.h&quot;int g_test;main.cppint _tmain(int argc, _TCHAR* argv[]){    g_test=2;    std::cout&lt;&lt;g_test;    return 0;}</code></pre><p>提示错误，因为此时main中不能调用到g_test。<br>1&gt;d:\microsoft visual studio 9.0\projects\testcpp\testcpp\testcpp.cpp(25) : error C2065: “g_test”: 未声明的标识符<br>1&gt;d:\microsoft visual studio 9.0\projects\testcpp\testcpp\testcpp.cpp(26) : error C2065: “g_test”: 未声明的标识符</p><p>（2）有extern声明，无变量定义。</p><pre><code>stdafx.hextern int g_test;main.cppint _tmain(int argc, _TCHAR* argv[]){    g_test=2;    std::cout&lt;&lt;g_test;    return 0;}</code></pre><p>提示错误，因为extern只是声明，并没有定义，也就没有空间的分配，而这时一个链接错误，编译的时候没办法发现。<br>1&gt;TestCpp.obj : error LNK2001: 无法解析的外部符号 “int g_test” (?g_test@@3HA)<br>1&gt;D:\Microsoft Visual Studio 9.0\Projects\TestCpp\Debug\TestCpp.exe : fatal error LNK1120: 1 个无法解析的外部命令</p><p>（3）有extern声明，也有变量定义。</p><pre><code>stdafx.cpp#include &quot;stdafx.h&quot;int g_test;stdafx.hextern int g_test;main.cppint _tmain(int argc, _TCHAR* argv[]){    g_test=2;    std::cout&lt;&lt;g_test;    return 0;}</code></pre><p>程序执行正常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[toc]&lt;/p&gt;
&lt;h1 id=&quot;首先-明白-这个单词-是什么意思？&quot;&gt;&lt;a href=&quot;#首先-明白-这个单词-是什么意思？&quot; class=&quot;headerlink&quot; title=&quot;首先 明白 这个单词 是什么意思？&quot;&gt;&lt;/a&gt;首先 明白 这个单词 是什么意思？&lt;/h1
      
    
    </summary>
    
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>static关键字</title>
    <link href="http://yoursite.com/2019/09/08/static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/09/08/static关键字/</id>
    <published>2019-09-08T04:57:09.000Z</published>
    <updated>2019-09-08T05:19:50.530Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h1 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h1><ol><li>在全局变量前面，加上关键字 static  ，该变量就成为一个静态全局变量<br>特点：</li><li>1 在全局数据区分配内存</li><li>2 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值 是随机的，除非它被显式初始化）</li><li>3 <strong>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见。</strong></li></ol><p>理解： 避免变量 命名冲突，和其他文件中变量相撞。</p><pre><code>//Example 2//File1#include &lt;iostream.h&gt;void fn();static int n; //定义静态全局变量void main(){ 　　n=20; 　　cout&lt;&lt;n&lt;&lt;endl; 　　fn();}//File2#include &lt;iostream.h&gt;extern int n;void fn(){　　 n++; 　　cout&lt;&lt;n&lt;&lt;endl;}</code></pre><p>编译并运行Example 2，您就会发现上述代码可以分别通过编译，但运行时出现错误。试着将 “static int n; //定义静态全局变量”改为 “int n; //定义全局变量”<br>再次编译运行程序，细心体会“全局变量”和”静态全局变量”的区别。</p><h1 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h1><p>特点：</p><ol><li>静态局部变量 在全局数据区分配内存</li><li>静态局部变量在程序执行到该对象的声明处时，被第一次初始化，即 以后的函数调用不在进行初始化。</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0</li><li>会始终驻留在 全局数据区，直到程序运行结束，但其作用域为局部作用域，当定义它的函数或者语句块结束时，其作用域随之结束。</li></ol><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。 </p><p>理解：静态全局变量 维护 比 静态局部变量维护开销大?<br>static 默认进行初始化为0，并且数据是放在全局数据区中的。两次函数调用就可以对同一个变量进行操作。</p><h1 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h1><ol><li>只能在声明它的文件中可用，其他文件不能被使用 ，从而避免命名冲突</li></ol><h1 id="类中的static-关键字"><a href="#类中的static-关键字" class="headerlink" title="类中的static 关键字"></a>类中的static 关键字</h1><h2 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h2><p>非静态数据成员，会存在多份拷贝，<br>静态数据成员，会存在一份拷贝，由该类型的所有对象共享访问。所以静态成员的值对每个对象都是一样的，它的值可以更新，</p><p><strong><em>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</em></strong></p><p> 静态数据成员和普通数据成员一样遵从public,protected,private访问规则； </p><p><strong><em>实现信息隐藏</em></strong>，<strong><em>静态数据成员可以是private成员，而全局变量不可以</em></strong></p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>普通函数拥有this 指针 会指向对象本身、<br>但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此不具有this 指针。</p><p>从而更进一步说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其余的<strong>静态成员函数</strong>。</p><pre><code>#include &lt;iostream.h&gt;class Myclass{public: 　　Myclass(int a,int b,int c); 　　static void GetSum();/声明静态成员函数private: 　　int a,b,c;　　 static int Sum;//声明静态数据成员};int Myclass::Sum=0;//定义并初始化静态数据成员Myclass::Myclass(int a,int b,int c){ 　　this-&gt;a=a; 　　this-&gt;b=b; 　　this-&gt;c=c; 　　Sum+=a+b+c; //非静态成员函数可以访问静态数据成员}void Myclass::GetSum() //静态成员函数的实现{　　// cout&lt;&lt;a&lt;&lt;endl; //错误代码，a是非静态数据成员 　　cout&lt;&lt;&quot;Sum=&quot;&lt;&lt;Sum&lt;&lt;endl;}void main(){ 　　Myclass M(1,2,3); 　　M.GetSum(); 　　Myclass N(4,5,6); 　　N.GetSum(); 　　Myclass::GetSum();}</code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>非静态成员函数可以任意访问静态成员函数和静态数据成员。</li><li>静态成员函数不能访问非静态成员函数和非静态数据成员。（因为没有this 指针）</li><li>由于没有this 指针的额外开销，静态成员函数与类的全局函数相比速度会有少许的增长。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[toc]&lt;/p&gt;
&lt;h1 id=&quot;静态全局变量&quot;&gt;&lt;a href=&quot;#静态全局变量&quot; class=&quot;headerlink&quot; title=&quot;静态全局变量&quot;&gt;&lt;/a&gt;静态全局变量&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在全局变量前面，加上关键字 static  ，该变量就成为一个静态全
      
    
    </summary>
    
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2019/09/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/08/单例模式/</id>
    <published>2019-09-08T04:55:22.000Z</published>
    <updated>2019-09-08T05:19:40.921Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">class singleton&#123;</span><br><span class="line">private:</span><br><span class="line">    static volatile singleton *p;</span><br><span class="line">    static pthread_mutex_t mtx;</span><br><span class="line">    singleton()&#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    static singleton * getInstance();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleton * singleton::p = NULL;</span><br><span class="line">pthread_mutex_t singleton::mtx;</span><br><span class="line"></span><br><span class="line">singleton * singleton::getInstance()&#123;</span><br><span class="line">    if (p == NULL)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mtx);</span><br><span class="line">        if (p == NULL)  p = new singleton;</span><br><span class="line">        pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    singleton * ptr = singleton::getInstance();</span><br><span class="line">    singleton * ptr1 = singleton::getInstance();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>git子模块</title>
    <link href="http://yoursite.com/2019/09/08/git%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/09/08/git子模块/</id>
    <published>2019-09-08T04:44:09.000Z</published>
    <updated>2019-09-08T05:20:04.931Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97</a></p><pre><code>git submodule init ;git submodule update;git checkout master ; git submodule foreach git checkout master ; git pull ; git submodule foreach git pull</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://git-sc
      
    
    </summary>
    
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>article title</title>
    <link href="http://yoursite.com/2019/09/08/article-title/"/>
    <id>http://yoursite.com/2019/09/08/article-title/</id>
    <published>2019-09-08T04:22:18.000Z</published>
    <updated>2019-09-08T04:22:18.418Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/09/08/hello-world/"/>
    <id>http://yoursite.com/2019/09/08/hello-world/</id>
    <published>2019-09-08T04:13:05.948Z</published>
    <updated>2019-09-08T04:13:05.948Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
