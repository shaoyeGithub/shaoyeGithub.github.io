<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Terry Blog</title>
  
  <subtitle>Stay Hungry，Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-08T11:49:19.882Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Terry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++基础</title>
    <link href="http://yoursite.com/2019/09/08/C-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/09/08/C-基础/</id>
    <published>2019-09-08T11:43:06.000Z</published>
    <updated>2019-09-08T11:49:19.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-C-中四种类型转换"><a href="#1-C-中四种类型转换" class="headerlink" title="1. C++ 中四种类型转换"></a>1. C++ 中四种类型转换</h1><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>用于静态和非静态之间的转换<br>讲const 类型转化成非const类型</p><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>动态转化，只能用于<strong>虚函数</strong>    的类，用于类层次间向上或者向下转化，只能转化<strong>指针或者引用</strong>。</p><h3 id="什么是向上转化？"><a href="#什么是向上转化？" class="headerlink" title="什么是向上转化？"></a>什么是向上转化？</h3><p>子类转成基类</p><h3 id="什么是向下转化？"><a href="#什么是向下转化？" class="headerlink" title="什么是向下转化？"></a>什么是向下转化？</h3><p>基类转成子类</p><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_ cast"></a>static_ cast</h2><p>用于各种隐士类型转化，比如非const 转成const、void*转换成指针等，能用于多台的向上转化，假如是向下转化就是可能会不安全。（为什么？）</p><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>几乎什么都可以转，比如讲int 转成指针，可能会出问题，尽量少用。</p><h1 id="2-C-中四个智能指针"><a href="#2-C-中四个智能指针" class="headerlink" title="2. C++ 中四个智能指针"></a>2. C++ 中四个智能指针</h1><h2 id="为什么要使用智能指针？"><a href="#为什么要使用智能指针？" class="headerlink" title="为什么要使用智能指针？"></a>为什么要使用智能指针？</h2><p>智能指针主要用于解决指针未释放，内存泄漏的问题。首先智能指针就是一个类。当类的作用域结束后，会调用相关的析构函数去释放空间，从而解决内存泄漏问题。</p><h2 id="2-1-auto-ptr"><a href="#2-1-auto-ptr" class="headerlink" title="2.1 auto_ptr"></a>2.1 auto_ptr</h2><p>auto_ptr 可能会存在内存崩溃的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_ptr&lt; string&gt; p1 (new string (&quot;I reigned lonely as a cloud.”));</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2 = p1; //auto_ptr不会报错.</span><br></pre></td></tr></table></figure><p>p2剥夺了p1的所有权，但是当程序运行时访问p1，会报错。</p><h2 id="2-2-unique-ptr（替换auto-ptr）"><a href="#2-2-unique-ptr（替换auto-ptr）" class="headerlink" title="2.2 unique_ptr（替换auto_ptr）"></a>2.2 unique_ptr（替换auto_ptr）</h2><p>实现独占式拥有或严格拥有概念。保证同一时间只有一个智能指针用于该对象。<br>它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; p3 (new string (&quot;auto&quot;));   //#4</span><br><span class="line">unique_ptr&lt;string&gt; p4；                       //#5</span><br><span class="line">p4 = p3;//此时会报错！！</span><br></pre></td></tr></table></figure><p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。<br>另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; pu1(new string (&quot;hello world&quot;));</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      // #1 not allowed</span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = unique_ptr&lt;string&gt;(new string (&quot;You&quot;));   // #2 allowed</span><br></pre></td></tr></table></figure><p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; ps1, ps2;</span><br><span class="line">ps1 = demo(&quot;hello&quot;);</span><br><span class="line">ps2 = move(ps1);</span><br><span class="line">ps1 = demo(&quot;alexia&quot;);</span><br><span class="line">cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="2-3-shared-ptr"><a href="#2-3-shared-ptr" class="headerlink" title="2.3 shared_ptr"></a>2.3 shared_ptr</h2><p>shared_ptr实现<strong>共享式拥有</strong>概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 <strong><em>use_count()</em></strong> 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用 <strong><em>release()</em></strong> 时，当前指针会释放资源所有权，计数<strong>减一</strong>。当计数等于0时，资源会被释放</p><p>成员函数：</p><blockquote><p>use_count 返回引用计数的个数<br><strong>unique</strong> 返回是否是独占所有权( use_count 为 1)<br>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)<br>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少<br>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></p></blockquote><h2 id="2-4-weak-ptr"><a href="#2-4-weak-ptr" class="headerlink" title="2.4 weak_ptr"></a>2.4 weak_ptr</h2><p>weak_ptr 是一种<strong>不控制对象生命周期</strong>的智能指针, 它指向一个 <strong>shared_ptr</strong> 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。</p><p>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, <strong>它的构造和析构不会引起引用记数的增加或减少</strong>。</p><p>weak_ptr是用来<strong>解决shared_ptr相互引用时的死锁问题</strong>,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，<strong>它可以通过调用lock函数来获得shared_ptr。</strong></p><p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p><p>注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</p><h2 id="3-什么是野指针？"><a href="#3-什么是野指针？" class="headerlink" title="3. 什么是野指针？"></a>3. 什么是野指针？</h2><p>野指针就是指向一个已经删除的对象，或者未申请访问受限内存区域的指针。</p><h2 id="4-请你回答一下为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点-虚函数-析构函数"><a href="#4-请你回答一下为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数-考点-虚函数-析构函数" class="headerlink" title="4. 请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数"></a>4. 请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 考点:虚函数 析构函数</h2><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p><p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p><h1 id="5-fork-函数"><a href="#5-fork-函数" class="headerlink" title="5. fork() 函数"></a>5. fork() 函数</h1><p>成功调用fork 函数会创建一个新的进程，它几乎与调用fork进程（）一模一样，两个进程都会继续进行，在子进程中，fork调用会返回0，在父进程中，fork（）调用会<strong>子进程的pid</strong>，如果出现错误，fork返回一个 负值。</p><p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p><h1 id="6-请你说一说strcpy和strlen"><a href="#6-请你说一说strcpy和strlen" class="headerlink" title="6. 请你说一说strcpy和strlen"></a>6. 请你说一说strcpy和strlen</h1><p>strcpy是字符串拷贝函数，原型：<br>char <em>strcpy(char</em> dest, const char *src);</p><p>从src逐字节拷贝到dest，直到遇到’\0’结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。<br>strlen函数是计算字符串长度的函数，返回从开始到’\0’之间的字符个数。</p><h1 id="7-在main函数之前执行"><a href="#7-在main函数之前执行" class="headerlink" title="7. 在main函数之前执行"></a>7. 在main函数之前执行</h1><pre><code>__attribute((constructor))void before(){    printf(&quot;before main\n&quot;);}</code></pre><h1 id="8-智能指针shared-ptr的实现"><a href="#8-智能指针shared-ptr的实现" class="headerlink" title="8. 智能指针shared_ptr的实现"></a>8. 智能指针shared_ptr的实现</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-C-中四种类型转换&quot;&gt;&lt;a href=&quot;#1-C-中四种类型转换&quot; class=&quot;headerlink&quot; title=&quot;1. C++ 中四种类型转换&quot;&gt;&lt;/a&gt;1. C++ 中四种类型转换&lt;/h1&gt;&lt;h2 id=&quot;const-cast&quot;&gt;&lt;a href=&quot;#c
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://yoursite.com/2019/09/08/%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/09/08/排序/</id>
    <published>2019-09-08T11:30:22.000Z</published>
    <updated>2019-09-08T11:42:27.463Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/2019090819415719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="冒泡算法"><a href="#冒泡算法" class="headerlink" title="冒泡算法"></a>冒泡算法</h1><pre><code>void swap(int arr[], int x, int y){    int temp = arr[x];    arr[x] = arr[y];    arr[y] = temp;}void BubbleSort(int arr[], int n){    for (int i = 0; i &lt; n - 1; i++) {        for (int j = 0; j &lt; n - i-1; j++)        {            if (arr[j] arr[j + 1])                swap(arr, j, j + 1);        }    }} </code></pre><h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><pre><code>void QuickSort(int arr[], int left, int right){    if (left &gt; right)        return;    int pivot = arr[left];    int low = left;    int high = right;    while (low &lt; high)    {        while (arr[high] &gt; pivot &amp;&amp; high &gt; low)            high--;        if (low &lt; high)            arr[low++] = arr[high];        while (arr[low] &lt; pivot &amp;&amp; high &gt; low)            low++;        if (low &lt; high)            arr[high--] = arr[low];    }    arr[low] = pivot;    QuickSort(arr, left, low - 1);    QuickSort(arr, low + 1 , right);}</code></pre><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><pre><code>void HeapBuild(int arr[], int index, int len){    int CurP = arr[index];    int child = 2 * index + 1;    while (child &lt; len)    {        if (child + 1 &lt; len &amp;&amp; arr[child] &lt; arr[child + 1])            child++;        if (CurP &lt; arr[child])        {            arr[index] = arr[child];            index = child;            child = 2 * index + 1;        }        else        {            break;        }    }    arr[index] = CurP;}void HeapSort(int arr[],int len){    for (int i = len / 2 - 1; i &gt;= 0; i--)        HeapBuild(arr, i, len);    for (int i = len - 1; i &gt;= 0; i--)    {        swap(arr, 0, i);        HeapBuild(arr, 0, i);    }}</code></pre><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><pre><code>void Merge(int arr[],int left,int end,int mid,int temp[]){    int i = left;    //int mid = (end - left) / 2;    int j = mid+1;    int t = 0;    while (i &lt;= mid &amp;&amp; j &lt;= end)    {        if (arr[i] &lt;= arr[j])        {            temp[t++] = arr[i++];        }        else        {            temp[t++] = arr[j++];        }    }    while (i &lt;= mid)    {        temp[t++] = arr[i++];    }    while (j &lt;= end)    {        temp[t++] = arr[j++];    }    t = 0;    while (left &lt;= end)    {        arr[left++] = temp[t++];    }}void MergeSort(int arr[], int left, int end,int temp[]){    if (left &lt; end)    {        int mid = (end + left) / 2;        MergeSort(arr, left, mid,temp);        MergeSort(arr, mid + 1, end,temp);        Merge(arr, left, end,mid,temp);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019090819415719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="http://yoursite.com/2019/09/08/STL/"/>
    <id>http://yoursite.com/2019/09/08/STL/</id>
    <published>2019-09-08T06:19:14.000Z</published>
    <updated>2019-09-08T06:59:20.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL-六大组件-功能与运用"><a href="#STL-六大组件-功能与运用" class="headerlink" title="STL 六大组件 功能与运用"></a>STL 六大组件 功能与运用</h1><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1. 容器"></a>1. 容器</h2><p>各种数据结构 ，vector ，list ，deque，set，map，从实现角度来看，STL容器是一种<strong>class template</strong></p><h2 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h2><p>各种常用算法，sort，search，copy，erase，从实现角度来看，STL容器是一种<strong>function template</strong></p><h2 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3. 迭代器"></a>3. 迭代器</h2><p>扮演容器与算法之间的胶合剂，<strong>泛型指针</strong>，有五种类型，从实现角度来说，就是把operator<em>，operator-&gt;,opreator++,opreator–等指针相关操作予以重载的class template ，每个STL容器都附带有自己专属的迭代器。*</em>原生指针也是一种迭代器。**</p><h2 id="4-仿函数"><a href="#4-仿函数" class="headerlink" title="4. 仿函数"></a>4. 仿函数</h2><p>什么是仿函数？<br><strong>行为类似函数。</strong> 好好体会下这句话</p><h2 id="5-配接器（adapters）"><a href="#5-配接器（adapters）" class="headerlink" title="5. 配接器（adapters）"></a>5. 配接器（adapters）</h2><p>顾名思义，想想配接器模式（adapter design）</p><h2 id="6-配置器（allocators）"><a href="#6-配置器（allocators）" class="headerlink" title="6. 配置器（allocators）"></a>6. 配置器（allocators）</h2><p>负责空间配置与管理，实现了动态空间配置，空间管理，空间释放。</p><hr><h1 id="空间配置器（allocator）"><a href="#空间配置器（allocator）" class="headerlink" title="空间配置器（allocator）"></a>空间配置器（allocator）</h1><p><img src="https://img-blog.csdnimg.cn/20190523151956853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20190523152031876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>SGI设计了<strong>双层级配置器</strong>（面试会被问道），主要是为了解决小型区块所可能造成的内存破碎问题。<br>SGI第一级配置器通过 <strong>malloc和 free</strong> 完成内存的配置与释放。第二级配置器则通过不同的策略来进行操作：首先，看配置区块的大小，看其是否超过128bytes，是的话，给第一级配置器，当配置器区块小于128bytes时，采用<strong>memory pool</strong> 整理方式。<br>那么，究竟只用第一级就OK，还是同时都用呢，要看__USE_MALLOC 这个参数是否被定义。（侯捷老师这里注：说这个参数名字并不理想，因为无论如何malloc总是要被调用的，对吧）。具体过程看下图。<br><img src="https://img-blog.csdnimg.cn/2019052315362462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p>下面逐个讲解第一级配置器和第二级配置器</p><p><strong>第一级配置器</strong>：</p><p>实现类似C++ new-handler 的机制，不能直接运用该机制，是因为他并非使用operator new 来配置内存。</p><p>那么什么是new-handler 机制呢，可以要求系统在内存配置需求无法被满足的时候，调用一个你指定的函数，换句话说，当内存配置不好使的时候，你可以让系统执行你指定的函数。</p><p>也就是  :: operator new 没有完成任务，在丢出std::bad_alloc 异常状态之前，会先调用有客户端也就是你指定的处理例程，处理例程通常叫做new-handler。</p><p><strong>侯老师在这里多嘱咐了几句：说设计和设定“内存不足处理例程”是客户端的责任，有特定的套路</strong></p><p><strong>第二级配置器：</strong><br>小于128bytes时，以内存池管理（memory pool），该方法又称为（sub-allocation）;每次配置一大块内存，并维护对应之自由链表（free-list）。<br>有16个free-lists，各自管理不同大小的小额区块，例如8,16,32,,,<br>每次配置一大块内存，并维护对应的free list，若下次还是相同大小的内存需求，直接从free-list中拨出。</p><ol><li>allocate（）函数 ，该函数，首先判断区块大小，大于128，嗯，你懂得，小于的话，就看对应的free-list。如果free-list 内有能用的区块，就直接拿来用，没有的话，将区块上调至8倍数边界，然后调用refill（）函数，准备为free-list重新填充空间。</li><li>dellocate（）函数，同样的，首先判断区块大小，大于128，小于128，就找到对应的free-list ，将区块回收。</li><li>chunk_alloc() 函数，从内存池中取空间给free-list，首先会判断水量够不够，够的话，就取出20个区块给free-list，不够20个区块，还可以供应一个以上的话，就把这些区块拨出去，问题来了，假如一个都不够的话，该怎么办，对客户端显然无法交代，对不对，通过malloc（）从heap中配置内存，为池子里注入新的水以供使用。新水量为需求的两倍，再加上一个随着配置次数增加而越来越大的附加量。<br><img src="https://img-blog.csdnimg.cn/20190523161415571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20190523161218338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190523161252757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h2 id="内存池（面试题）"><a href="#内存池（面试题）" class="headerlink" title="内存池（面试题）"></a>内存池（面试题）</h2><hr><h1 id="迭代器（iterators）概念与traits编程技法"><a href="#迭代器（iterators）概念与traits编程技法" class="headerlink" title="迭代器（iterators）概念与traits编程技法"></a>迭代器（iterators）概念与traits编程技法</h1><p>STL 的中心思想在于：将数据容器和算法分开，彼此独立设计，最后再以一贴胶水将两者联系在一起。</p><p>迭代器是一种smart pointer</p><h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector 与array 的区别是什么呢？<br>array 是静态空间，一旦配置了就不能改变，vector是动态空间。vector数据空间是连续线性空间，为了降低空间配置是的速度成本，vector实际配置的大小可能比客户端需求量更大一些。</p><p>vector 动态增加大小，并不是在原来的空间之后接续新空间（因为无法保证原始空间后面是不是还有可以分配的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原始空间。</p><p>vector 为<strong>单向数组</strong>，只能pushback 和pop back<br><img src="https://img-blog.csdnimg.cn/20190523162903486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>腾讯面试题：通过三个迭代器：start，finish，end_of_storage 完成内存分配。</p><hr><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>list 有个一个prev 和next ，所以为双向链表，而且还是<strong>环装双向链表</strong></p><hr><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque是一个双向开口的<strong>连续线性空间</strong>。可以在头尾两端分别做元素的插入和删除操作。</p><p>deque 的 迭代器的比较复杂相比于vector<br>因此，除非必要，我们应尽可能选择使用vector，而非deque，例如，对deuqe进行排序操作，为了高效，可以将deque先完整复制到一个vector，将vector排序后（利用STL sort 算法），在复制回deque。</p><p>deque 数据结构 采用所谓map 作为主控，map是一小块连续空间，其中每个元素（此处叫node，节点）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque 的存储空间主体。我们可以指定缓冲区的大小。默认为512bytes。</p><p><img src="https://img-blog.csdnimg.cn/20190523191621566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>以某种既有容器作为底部结构，将其接口改变，让其满足“先进后出”的特性，形成一个stack，是很容易做到的。</p><p><img src="https://img-blog.csdnimg.cn/20190523170838723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p><img src="https://img-blog.csdnimg.cn/20190523170903185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p><img src="https://img-blog.csdnimg.cn/2019052317101699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p><img src="https://img-blog.csdnimg.cn/20190523171111432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h2><p>单向链表</p><h1 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h1><h2 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h2><p><img src="https://img-blog.csdnimg.cn/20190523171320794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>底层数据结构 是RB-tree </p><p>面对关联式容器，应该使用其所提供的find函数来搜寻元素，效率更高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itel = iset.find(3);          //查找3这个元素 而不是用find（first，last，value）</span><br></pre></td></tr></table></figure><hr><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>底层也是RB-tree 树  &lt;key,value&gt;</p><h2 id="multiset-amp-multimap"><a href="#multiset-amp-multimap" class="headerlink" title="multiset &amp; multimap"></a>multiset &amp; multimap</h2><p>multiset 的特性以及用法和set一致的，唯一的区别在于，它允许键值重复，map和multimap 也是如此</p><h2 id="hash-set-amp-hash-map-amp-hash-multiset-amp-hash-multimap"><a href="#hash-set-amp-hash-map-amp-hash-multiset-amp-hash-multimap" class="headerlink" title="hash_set &amp; hash_map &amp; hash_multiset &amp; hash_multimap"></a>hash_set &amp; hash_map &amp; hash_multiset &amp; hash_multimap</h2><p>底层都是hashtable</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;0,1,2,3,4,5,6,6,6,7,8&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for_each(begin(),end(),display&lt;int&gt;());  // 可以用来打印  </span><br><span class="line">adjacet_find(begin(),end());// 找到相邻元素值相等的第一个元素 ,这里为6</span><br><span class="line">adjacet_find(begin(),end(),equal_to&lt;int&gt;());// 找到相邻元素值相等的第一个元素 ,这里为6</span><br><span class="line">count(begin(),end(),6) ;// 数组中值为6的个数</span><br><span class="line">count_if(begin(),end(),bind2nd(less&lt;int&gt;()),7); // 找出小于7的元素个数 </span><br><span class="line">find_if(begin(),end(),bind2nd(greater&lt;int&gt;()),2)// 找出第一个大于2的元素的位置</span><br></pre></td></tr></table></figure><p>注：假如未来有一天，我会在这里加上代码，记上常用的算法</p><h1 id="仿函数（另名-函数对象-function-objects）"><a href="#仿函数（另名-函数对象-function-objects）" class="headerlink" title="仿函数（另名 函数对象 function objects）"></a>仿函数（另名 函数对象 function objects）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//用户继承 binary_function,便可以取得该仿函数的各种相应的类型</span><br><span class="line">eg：</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct plus :public binary_function&lt;T,T,T&gt;&#123;</span><br><span class="line">    T  opreator()(const T&amp; x,const T&amp; y) const &#123;return x+y&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STL-六大组件-功能与运用&quot;&gt;&lt;a href=&quot;#STL-六大组件-功能与运用&quot; class=&quot;headerlink&quot; title=&quot;STL 六大组件 功能与运用&quot;&gt;&lt;/a&gt;STL 六大组件 功能与运用&lt;/h1&gt;&lt;h2 id=&quot;1-容器&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>面经总结基础知识</title>
    <link href="http://yoursite.com/2019/09/08/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/09/08/面经总结基础知识/</id>
    <published>2019-09-08T06:18:19.000Z</published>
    <updated>2019-09-08T07:00:24.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1-ping命令的基本原理？"><a href="#1-ping命令的基本原理？" class="headerlink" title="1.ping命令的基本原理？"></a>1.ping命令的基本原理？</h2><p>【答】ping 命令用来测试两个主机间的连通性，使用ICMP（Internet Control Message Protocol，网际控制协议）中会送请求和会送回答请求，是应用层使用网络层ICMP的一个例子，没有通过运输层的TCP和UDP。</p><p>ping命令使得本地主机连续发送了四个ICMP回送请求报文，然后远程的主机正常工作的话就会像图中显示的结果一样，响应并发回ICMP回送回答报文。每个报文都有其时间戳，所以最终得出了往返时间以及报文的发送接收丢失的结果。</p><h2 id="2-TCP-拥塞控制和流量控制的方法"><a href="#2-TCP-拥塞控制和流量控制的方法" class="headerlink" title="2. TCP 拥塞控制和流量控制的方法"></a>2. TCP 拥塞控制和流量控制的方法</h2><p>可以参考：<a href="https://www.cnblogs.com/wxgblogs/p/5616829.html" target="_blank" rel="noopener">https://www.cnblogs.com/wxgblogs/p/5616829.html</a> ，总结的不错</p><h2 id="2-1-拥塞控制"><a href="#2-1-拥塞控制" class="headerlink" title="2.1 拥塞控制"></a>2.1 拥塞控制</h2><p>【答】 拥塞控制： 快重传，慢开始，拥塞避免，以及快回复。</p><h2 id="2-2-流量控制"><a href="#2-2-流量控制" class="headerlink" title="2.2 流量控制"></a>2.2 流量控制</h2><p>【答】 流量控制就是让发送方的发送速率不要太快，让接收方来得及接受。<br>是通过滑动窗口来控制。</p><hr><h2 id="3-IPV4-的三类地址"><a href="#3-IPV4-的三类地址" class="headerlink" title="3. IPV4 的三类地址"></a>3. IPV4 的三类地址</h2><p><img src="https://img-blog.csdnimg.cn/2019052811441341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-虚拟内存介绍一下"><a href="#1-虚拟内存介绍一下" class="headerlink" title="1. 虚拟内存介绍一下"></a>1. 虚拟内存介绍一下</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;h2 id=&quot;1-ping命令的基本原理？&quot;&gt;&lt;a href=&quot;#1-ping命令的基本原理？&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="面经" scheme="http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++面试问题总结(CPP基础、网络编程)</title>
    <link href="http://yoursite.com/2019/09/08/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93-CPP%E5%9F%BA%E7%A1%80%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/09/08/C-面试问题总结-CPP基础、网络编程/</id>
    <published>2019-09-08T06:16:56.000Z</published>
    <updated>2019-09-08T06:57:19.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-main-函数-执行前-和执行后会执行什么？"><a href="#1-main-函数-执行前-和执行后会执行什么？" class="headerlink" title="1. main 函数 执行前 和执行后会执行什么？"></a>1. main 函数 执行前 和执行后会执行什么？</h1><p>【答】main 函数执行之前，主要是初始化系统相关的资源以及函数的初始化工作</p><ol><li>设置栈指针</li><li>初始化static 静态和global 全局变量，即data段的内容</li><li>将还没有初始化的全局变量进行赋值，eg：数值型 short int long 等为0，bool 为false 指针为null，等等，即 bss段</li><li>运行全局构造器，进行 C++ 中的函数构造</li><li>将main 函数的参数，argc，argv 等传递给main函数，才能 真正运行</li></ol><p>main 函数执行之后，会运行 全局对象的析构函数<br>可以用_oneexit 注册一个 函数，它会在main 之后 执行</p><p>如果你需要加入一段在main退出后执行的代码，可以使用atexit()函数，注册一个函数。 </p><hr><h1 id="2-网络粘包问题"><a href="#2-网络粘包问题" class="headerlink" title="2. 网络粘包问题"></a>2. 网络粘包问题</h1><p>参考 ：<a href="https://blog.csdn.net/zhangxinrun/article/details/6721495" target="_blank" rel="noopener">https://blog.csdn.net/zhangxinrun/article/details/6721495</a></p><h2 id="2-1-长连接-和-短连接"><a href="#2-1-长连接-和-短连接" class="headerlink" title="2.1 长连接 和 短连接"></a>2.1 长连接 和 短连接</h2><p>【答】</p><ol><li>长连接<br> client 与 server 建立连接后<strong>不断开</strong> ，然后再进行 报文发送和 报文接受</li><li>短连接<br>client 与 server 每一次进行报文通讯时才进行连接建立，交易完毕后立即断开连接，适用于一点对多点的通讯，例如多个client 与 一个 server</li></ol><h2 id="2-2-什么时候需要考虑粘包问题？"><a href="#2-2-什么时候需要考虑粘包问题？" class="headerlink" title="2.2 什么时候需要考虑粘包问题？"></a>2.2 什么时候需要考虑粘包问题？</h2><ol><li><strong>如果利用tcp 每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题</strong></li><li>1 因为只有一种包结构，类似于http协议，关闭连接主要要双方都发送 close 连接。</li><li><strong>如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接受存储就ok，也不用考虑粘包</strong></li><li>Ding~~ 如果双方建立建立，需要在连接后一段时间内发送不同的数据结构，所以一般需要在 头 加上 一个数据长度之类的包，以确保接受。</li></ol><h2 id="2-3-粘包出现原因："><a href="#2-3-粘包出现原因：" class="headerlink" title="2.3 粘包出现原因："></a>2.3 粘包出现原因：</h2><p>在流传输中，udp 不会出现粘包，因为它有消息边界（参考windows 网络编程）</p><hr><ol><li>发送端需要等缓冲区满才发送出去，会造成粘包</li><li>接受方不及时接受缓冲区的包，造成多个包接受</li></ol><h2 id="2-4-解决方法"><a href="#2-4-解决方法" class="headerlink" title="2.4 解决方法"></a>2.4 解决方法</h2><ol><li>对于发送方引起的粘包现象，用户可通过编程设置类避免，TCP提供了强制数据立即传送的push 指令，也就是说不必等着 缓冲区满才发送出去，</li><li>对于接受方引起的粘包，则可以通过优化程序设计，精简接受进程工作量，提高接受进程优先级等措施，使其及时接受数据，从而避免出现粘包问题，</li><li>由 接受方控制，将一包数据按结构 字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包</li></ol><p>以上提到的三种措施，都有其不足之处。<br>第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</p><p>第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</p><p>第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p><h2 id="2-5-网络现象解释"><a href="#2-5-网络现象解释" class="headerlink" title="2.5 网络现象解释"></a>2.5 网络现象解释</h2><p>A.先接收到data1,然后接收到data2.<br>B.先接收到data1的部分数据,然后接收到data1余下的部分以及data2的全部.<br>C.先接收到了data1的全部数据和data2的部分数据,然后接收到了data2的余下的数据.<br>D.一次性接收到了data1和data2的全部数据.</p><p>为什么会出现B.C.D的情况.<br>“粘包”可发生在发送端也可发生在接收端.</p><p>1.<strong>由Nagle算法造成的发送端的粘包</strong>:Nagle算法是一种改善网络传输效率的算法.简单的说,当我们提交一段数据给TCP发送时,TCP并不立刻发送此段数据,而是等待一小段时间,看看在等待期间是否还有要发送的数据,若有则会一次把这两段数据发送出去.这是对Nagle算法一个简单的解释,详细的请看相关书籍.象C和D的情况就有可能是Nagle算法造成的.</p><p>注: Nagle算法  用于自动连接许多的小缓冲器消息；这一过程（称为nagling）通过减少必须发送包的个数来增加网络软件系统的效率。</p><p>2.<strong>接收端接收不及时造成的接收端粘包</strong>:TCP会把接收到的数据存在自己的缓冲区中,然后通知应用层取数据.当应用层由于某些原因不能及时的把TCP的数据取出来,就会造成TCP缓冲区中存放了几段数据.</p><h2 id="2-6-UDP-会出现粘包问题吗？"><a href="#2-6-UDP-会出现粘包问题吗？" class="headerlink" title="2.6 UDP 会出现粘包问题吗？"></a>2.6 UDP 会出现粘包问题吗？</h2><p>【答】</p><ol><li>对于UDP，<strong>不会使用块的合并优化算法</strong>，这样，实际上目前认为，是由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。所以UDP不会出现粘包问题</li></ol><hr><h2 id="2-7-保护消息边界和流"><a href="#2-7-保护消息边界和流" class="headerlink" title="2.7 保护消息边界和流"></a>2.7 保护消息边界和流</h2><p>参考：<a href="https://blog.csdn.net/tiandijun/article/details/41961785" target="_blank" rel="noopener">https://blog.csdn.net/tiandijun/article/details/41961785</a></p><hr><p>保护消息边界和流</p><p>那么什么是保护消息边界和流呢?</p><p><strong>保护消息边界</strong>，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包。而面向流则是指无保护消息保护边界的，如果发送端连续发送数据，接收端有可能在一次接收动作中，会接收两个或者更多的数据包。</p><p>例如，我们连续发送三个数据包，大小分别是2k，4k ，8k,这三个数据包，都已经到达了接收端的网络堆栈中，如果使用UDP协议，不管我们使用多大的接收缓冲区去接收数据，我们必须有三次接收动作，才能够把所有的数据包接收完.而使用TCP协议，我们只要把接收的缓冲区大小设置在14k以上，我们就能够一次把所有的数据包接收下来，只需要有一次接收动作。</p><p>注意：</p><p>这就是因为UDP协议的保护消息边界使得每一个消息都是独立的。而流传输却把数据当作一串数据流，他不认为数据是一个一个的消息。所以有很多人在使用tcp协议通讯的时候，并不清楚tcp是基于流的传输，当连续发送数据的时候，他们时常会认识tcp会丢包。其实不然，因为当他们使用的缓冲区足够大时，他们有可能会一次接收到两个甚至更多的数据包，而很多人往往会忽视这一点，只解析检查了第一个数据包，而已经接收的其他数据包却被忽略了。所以大家如果要作这类的网络编程的时候,必须要注意这一点。</p><hr><h1 id="3-内存池的设计"><a href="#3-内存池的设计" class="headerlink" title="3. 内存池的设计"></a>3. 内存池的设计</h1><p>参考 STL源码解析 ，其中有对 STL 内存池的介绍</p><h1 id="4-网络编程中的加密算法"><a href="#4-网络编程中的加密算法" class="headerlink" title="4. 网络编程中的加密算法"></a>4. 网络编程中的加密算法</h1><h2 id="4-1-如何解决数据传输的安全问题？"><a href="#4-1-如何解决数据传输的安全问题？" class="headerlink" title="4.1 如何解决数据传输的安全问题？"></a>4.1 如何解决数据传输的安全问题？</h2><h2 id="4-2-加密算法"><a href="#4-2-加密算法" class="headerlink" title="4.2 加密算法"></a>4.2 加密算法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-main-函数-执行前-和执行后会执行什么？&quot;&gt;&lt;a href=&quot;#1-main-函数-执行前-和执行后会执行什么？&quot; class=&quot;headerlink&quot; title=&quot;1. main 函数 执行前 和执行后会执行什么？&quot;&gt;&lt;/a&gt;1. main 函数 执行
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用FileZilla 上传 文件 到 linux 时 提示550 Permission denied</title>
    <link href="http://yoursite.com/2019/09/08/%E4%BD%BF%E7%94%A8FileZilla-%E4%B8%8A%E4%BC%A0-%E6%96%87%E4%BB%B6-%E5%88%B0-linux-%E6%97%B6-%E6%8F%90%E7%A4%BA550-Permission-denied/"/>
    <id>http://yoursite.com/2019/09/08/使用FileZilla-上传-文件-到-linux-时-提示550-Permission-denied/</id>
    <published>2019-09-08T06:15:46.000Z</published>
    <updated>2019-09-08T07:01:59.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>在Windows系统中使用FileZilla 上传文件时提示”550 Permission denied”错误时（如下图）<br><img src="https://img-blog.csdnimg.cn/20190621093601967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>FileZilla  不能使用<br><img src="https://img-blog.csdnimg.cn/20190621094517782.png" alt="在这里插入图片描述"></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>关键是第二步<br><img src="https://img-blog.csdnimg.cn/20190621094623148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题现象&quot;&gt;&lt;a href=&quot;#问题现象&quot; class=&quot;headerlink&quot; title=&quot;问题现象&quot;&gt;&lt;/a&gt;问题现象&lt;/h1&gt;&lt;p&gt;在Windows系统中使用FileZilla 上传文件时提示”550 Permission denied”错误时（如下图）&lt;
      
    
    </summary>
    
    
      <category term="bug解决" scheme="http://yoursite.com/categories/bug%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="bug解决" scheme="http://yoursite.com/tags/bug%E8%A7%A3%E5%86%B3/"/>
    
  </entry>
  
  <entry>
    <title>微服务</title>
    <link href="http://yoursite.com/2019/09/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/09/08/微服务/</id>
    <published>2019-09-08T06:15:02.000Z</published>
    <updated>2019-09-08T07:01:31.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>微服务是由以<strong>单一应用程序</strong>构成的<strong>小服务</strong>，自己拥有自己的行程与轻量化处理，服务依<strong>业务功能</strong>设计，以<strong>全自动</strong>的方式部署，与其他服务使用HTTP API 通信。<br>同时服务会使用最小的规模的集中管理（例如Docker）能力，服务可以用不同的编程语言与数据库等组件实现。</p><h1 id="核心想法"><a href="#核心想法" class="headerlink" title="核心想法"></a>核心想法</h1><p>是让服务由类似Unix管道的访问方式使用，而且复杂的服务背后是使用简单URI来开放接口，任何服务，任何细粒都能被开发。</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>微服务理念中有数个数据库的规划方式。</p><p>每个服务都各有一个数据库，同属性的服务可共享同个数据库。<br>所有服务都共享同个数据库，但是不同表格，并且不会跨域访问。<br>每个服务都有自己的数据库，就算是同属性的服务也是，数据库并不会共享。</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>一个微服务架构的应用程序有下列特性：</p><ol><li>每个服务都容易被取代</li><li>服务是以能力来组织的，例如用户界面、前端、推荐系统、账单或是物流</li><li>由于功能被拆分成多个服务，因此可以由不同的编程语言、数据库实现</li><li>架构是对称而非分层（即 消费者和生产者的关系）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;微服务是由以&lt;strong&gt;单一应用程序&lt;/strong&gt;构成的&lt;strong&gt;小服务&lt;/strong&gt;，自己拥有自己的行程与轻量化处理，服
      
    
    </summary>
    
    
      <category term="软件知识" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="软件知识" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>启动zookeeper成功查看状态时却显示It is probably not running</title>
    <link href="http://yoursite.com/2019/09/08/%E5%90%AF%E5%8A%A8zookeeper%E6%88%90%E5%8A%9F%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81%E6%97%B6%E5%8D%B4%E6%98%BE%E7%A4%BAIt-is-probably-not-running/"/>
    <id>http://yoursite.com/2019/09/08/启动zookeeper成功查看状态时却显示It-is-probably-not-running/</id>
    <published>2019-09-08T06:13:20.000Z</published>
    <updated>2019-09-08T07:01:07.893Z</updated>
    
    <content type="html"><![CDATA[<p>可以 通过 下面命令来看错在哪里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start-foreground</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190626195718509.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可以 通过 下面命令来看错在哪里&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/09/08/cp%E3%80%81-%E9%80%9A%E9%85%8D%E7%AC%A6%E3%80%81mv%E5%91%BD%E4%BB%A4%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2019/09/08/cp、-通配符、mv命令实例/</id>
    <published>2019-09-08T06:12:14.336Z</published>
    <updated>2019-09-08T06:56:50.803Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: cp、 通配符、mv命令实例<br>date: 2019-09-08 14:12:14<br>tags: linux<br>categories: linux</p><hr><h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><p><img src="https://img-blog.csdnimg.cn/20190628152345979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h1><p><img src="https://img-blog.csdnimg.cn/20190628152507702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p><img src="https://img-blog.csdnimg.cn/20190628152012469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190628152047129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190628152110920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p>关于linux 的基础知识，包括文件系统和一些简单的指令<br><a href="http://billie66.github.io/TLCL/book/index.html" target="_blank" rel="noopener">http://billie66.github.io/TLCL/book/index.html</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: cp、 通配符、mv命令实例&lt;br&gt;date: 2019-09-08 14:12:14&lt;br&gt;tags: linux&lt;br&gt;categories: linux&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;cp&quot;&gt;&lt;a href=&quot;#cp&quot; class=&quot;hea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>符号链接和硬链接</title>
    <link href="http://yoursite.com/2019/09/08/%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2019/09/08/符号链接和硬链接/</id>
    <published>2019-09-08T06:11:14.000Z</published>
    <updated>2019-09-08T07:19:12.292Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20190628154216937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h1 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h1><p>一个文件至少有一个硬链接，因为文件名就是由链接创建的。</p><p>可以理解为C++ 中的引用，创建多个名字，链接到同一块文件数据中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#可以使用命令：</span><br><span class="line">ls -li</span><br><span class="line">来查看 命令的inode 的索引节点指向</span><br></pre></td></tr></table></figure><h2 id="硬链接-的两个缺点："><a href="#硬链接-的两个缺点：" class="headerlink" title="硬链接 的两个缺点："></a>硬链接 的两个缺点：</h2><ol><li>不能跨越物理设备</li><li>不能关联目录，只能是文件。<h1 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h1></li></ol><p>若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块（见 图 2.）。<br><img src="https://img-blog.csdnimg.cn/20190628154507324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190628154431314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW95ZV9jc2RuMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190628154216937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM
      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>TopK问题</title>
    <link href="http://yoursite.com/2019/09/08/TopK%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/09/08/TopK问题/</id>
    <published>2019-09-08T06:08:41.000Z</published>
    <updated>2019-09-08T06:59:33.004Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：<br>海量数据寻找 第 K大的数字</p><p>解法1： 首先随便找一个数字当做哨兵，比该数字大的放在哨兵的前面，假设为集合A，比该数字小的放到集合B。</p><p>统计出来集合A的大小，为T。</p><ol><li>如果T的大小比K小，则在 集合B 中寻找K-T大小的数字</li><li>如果T的大小比K大，则在集合A中继续寻找数字当做哨兵，进行集合分割。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题描述：&lt;br&gt;海量数据寻找 第 K大的数字&lt;/p&gt;
&lt;p&gt;解法1： 首先随便找一个数字当做哨兵，比该数字大的放在哨兵的前面，假设为集合A，比该数字小的放到集合B。&lt;/p&gt;
&lt;p&gt;统计出来集合A的大小，为T。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果T的大小比K小，则在 集合B 中
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>daemon 进程为什么要fork两次，与后台运行程序区别？</title>
    <link href="http://yoursite.com/2019/09/08/daemon-%E8%BF%9B%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81fork%E4%B8%A4%E6%AC%A1%EF%BC%8C%E4%B8%8E%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/09/08/daemon-进程为什么要fork两次，与后台运行程序区别？/</id>
    <published>2019-09-08T05:11:05.000Z</published>
    <updated>2019-09-08T05:20:27.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>daemon进程是后台守护进程<br>daemon函数存在的原因是因为控制终端由于某些原因（如断开终端链接）会发送一些信号的原因。而接收进程处理这些信号缺省动作会让进程退出。这些信号会由于终端上敲一些特殊按键而产生。</p></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int daemon(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = fork();</span><br><span class="line">    if( pid != 0 ) exit(0);//parent</span><br><span class="line">    //first children</span><br><span class="line">    if(setsid() == -1)</span><br><span class="line">    &#123;</span><br><span class="line">       printf(&quot;setsid failed\n&quot;);</span><br><span class="line">       assert(0);</span><br><span class="line">       exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    umask(0);</span><br><span class="line">    pid = fork();</span><br><span class="line">    if( pid != 0) exit(0);</span><br><span class="line">    //second children </span><br><span class="line">    chdir (&quot;/&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 3; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close (i);</span><br><span class="line">    &#125;</span><br><span class="line">    int stdfd = open (&quot;/dev/null&quot;, O_RDWR);</span><br><span class="line">    dup2(stdfd, STDOUT_FILENO);</span><br><span class="line">    dup2(stdfd, STDERR_FILENO);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol><li><p>第一次fork 的作用 是让shell 认为本条命令已经终止，不用挂在终端输入上。还有一个作用是为后面setsid服务。<strong>setsid的调用者不能让进程组组长（group leader）.此时父进程是进程组长。</strong></p></li><li><p>setsid() 是本函数最重要的一个调用。它完成了daemon函数想要做的大部分事情。调用完整个函数。子进程是会话组长(sid==pid)，也是进程组组长(pgid == pid)，并且脱离了原来控制终端。到了这一步，基本上不管控制终端如何怎么样。新的进程都不会收到那些信号。</p></li><li><p>经过前面2个步骤，基本想要做的都做了。第2次fork不是必须的。也看到很多开源服务没有fork第二次。fork第二次主要目的是。防止进程再次打开一个控制终端。因为打开一个控制终端的前提条件是该进程必须是会话组长。再fork一次，子进程ID != sid（sid是进程父进程的sid）。所以也无法打开新的控制终端。</p></li><li><p>daemon目的就是防止终端产生的一些信号让进程退出。上面函数并没有直接调用signal函数去处理它。而是间接通过fork和setsid函数使用更少代码优雅处理。而被有些人误以为是僵死进程的原因需要这样处理。</p></li></ol><h1 id="守护进程与用-amp-结尾的后台运行程序有什么区别呢？"><a href="#守护进程与用-amp-结尾的后台运行程序有什么区别呢？" class="headerlink" title="守护进程与用&amp;结尾的后台运行程序有什么区别呢？"></a>守护进程与用&amp;结尾的后台运行程序有什么区别呢？</h1><p>最大的区别有几点：<br>1)守护进程已经完全脱离终端控制台了，而后台程序并未完全脱离终端，在终端未关闭前还是会往终端输出结果<br>2)守护进程在关闭终端控制台时不会受影响，而后台程序会随用户退出而停止，需要在以nohug xxx &amp; 格式运行才能避免影响<br>3)守护进程的会话组和当前目录，文件描述符都是独立的。后台运行只是终端进行了一次fork，让程序在后台执行，这些都没改变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;daemon进程是后台守护进程&lt;br&gt;daemon函数存在的原因是因为控制终端由于某些原因（如断开终端链接）会发送一些信号的原因。而接收进程处理这些信号缺省动作会让进程退出。这些信号会由于终端上敲一些特殊按键而产生。&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>git fork 别人的项目后再同步</title>
    <link href="http://yoursite.com/2019/09/08/git-fork-%E5%88%AB%E4%BA%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%86%8D%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2019/09/08/git-fork-别人的项目后再同步/</id>
    <published>2019-09-08T05:06:03.000Z</published>
    <updated>2019-09-08T06:58:29.160Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream  fork的原始git 地址</span><br><span class="line">git remote -v ;</span><br><span class="line">git fetch upstream;                    </span><br><span class="line">git merge upstream/master;</span><br><span class="line">git pull origin master;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><pre><code>git remote -v                               //可以查看 添加后的分支状态git fetch upstream                    //从原始仓库更新同步代码git merge upstream/master            //合并到本地代码git pull origin master   // 更新合并自己的远程仓库的代码git push                   //向自己远程仓库推送刚才同步源仓库后的代码</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发</title>
    <link href="http://yoursite.com/2019/09/08/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/09/08/敏捷开发/</id>
    <published>2019-09-08T05:04:46.000Z</published>
    <updated>2019-09-08T07:00:45.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="敏捷开发的定义"><a href="#敏捷开发的定义" class="headerlink" title="敏捷开发的定义"></a>敏捷开发的定义</h1><p>以<strong>用户的需求进化</strong>作为核心，采用迭代、循序渐进的方法进行软件开发。</p><p>换句话说就是把一个大的项目分为多个相互联系，但也可以独立运行的小项目（story？<br>），并分别完成，在这个过程中软件一直处于<strong>可使用</strong>的状态。</p><h1 id="应用场景和特点"><a href="#应用场景和特点" class="headerlink" title="应用场景和特点"></a>应用场景和特点</h1><p>在软件项目的构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。</p><h1 id="开发宣言"><a href="#开发宣言" class="headerlink" title="开发宣言"></a>开发宣言</h1><pre><code>个体和交互 胜过过程和工具可以工作的软件 胜过 面面俱到的文档客户合作  胜过 合同谈判响应变化 胜过 遵循计划</code></pre><p>注：虽然右项也有价值，但是我们认为左项具有更大的价值。</p><h1 id="开发原则"><a href="#开发原则" class="headerlink" title="开发原则"></a>开发原则</h1><ol><li>快速迭代</li><li>让测试人员和开发者参与需求讨论</li><li>编写可测试的需求文档<br> 开始就用“用户故事”（user story）的方法来编写需求文档。</li><li>多沟通，尽量减少文档</li><li>做好产品原型<br>建议使用草图和模型来阐明用户界面，并不是所有人都可以理解一份复杂的文档，但人人都会看图。</li><li>及早考虑测试。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;敏捷开发的定义&quot;&gt;&lt;a href=&quot;#敏捷开发的定义&quot; class=&quot;headerlink&quot; title=&quot;敏捷开发的定义&quot;&gt;&lt;/a&gt;敏捷开发的定义&lt;/h1&gt;&lt;p&gt;以&lt;strong&gt;用户的需求进化&lt;/strong&gt;作为核心，采用迭代、循序渐进的方法进行软件开发。&lt;
      
    
    </summary>
    
    
      <category term="软件知识" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="软件知识" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>、释放命令</title>
    <link href="http://yoursite.com/2019/09/08/%E3%80%81%E9%87%8A%E6%94%BE%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/09/08/、释放命令/</id>
    <published>2019-09-08T05:03:41.000Z</published>
    <updated>2019-09-08T06:56:29.053Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">free -m  查看内存使用情况</span><br><span class="line"></span><br><span class="line">echo 1 &gt; /proc/sys/vm/drop_caches     // 释放页缓存</span><br><span class="line">echo 2 &gt; /proc/sys/vm/drop_caches     //释放dentries和inodes</span><br><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches     // 释放所有缓存</span><br><span class="line"></span><br><span class="line">到这里内存就释放完了，现在drop_caches中的值为1，如果现在想让操作系统重新分配内存，那么设置drop_caches的值为0即可：</span><br><span class="line"></span><br><span class="line">echo 0 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"></span><br><span class="line">free m</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>extren关键字</title>
    <link href="http://yoursite.com/2019/09/08/extren%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/09/08/extren关键字/</id>
    <published>2019-09-08T05:00:00.000Z</published>
    <updated>2019-09-08T06:58:15.954Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h1 id="首先-明白-这个单词-是什么意思？"><a href="#首先-明白-这个单词-是什么意思？" class="headerlink" title="首先 明白 这个单词 是什么意思？"></a>首先 明白 这个单词 是什么意思？</h1><p>Extern : 外部 的意思</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>置于 变量或者函数前，表示变量或者函数的定义在别的文件中，提示 编译器 遇到此变量和函数时，在其他模块中寻找其定义。</p><h1 id="作用-主要有两个"><a href="#作用-主要有两个" class="headerlink" title="作用  主要有两个"></a>作用  主要有两个</h1><p>第一个 ： 与 “C” 一起连用时，如 extern  “C” void fun（int a，int b）告诉编译器在编译fun 这个函数名的时候按照C的规则去编译。而不是C++</p><p>第二个： 当extern 不与C 一起修饰变量或函数时。如在头文件中：externa int g_int ;作用是：   声明函数或者全局变量 的作用范围的关键字，声明的函数或者变量可以在本模块或者其他模块中使用。记住，它 是<strong>一个声明不是定义</strong>。</p><p>extern用在变量声明中常常有这样一个作用，你在<em>.c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在</em>.h中并用extern来声明。</p><h1 id="具体解释及示例"><a href="#具体解释及示例" class="headerlink" title=".具体解释及示例"></a>.具体解释及示例</h1><p>2.1.extern的变量和函数声明<br>extern用于修饰变量或函数，用于声明当前变量或函数可以在本模块或者其他模块中使用。不过要记住的是extern只是声明，而不是定义，也就是说extern并不分配空间。而这个查找的过程是在连接的过程中进行的，因此编译阶段虽然找不到该变量或函数，但是也不会报错。下面用三个例子来看一看。</p><p>（1）无extern声明，有变量定义。</p><pre><code>stdafx.cpp#include &quot;stdafx.h&quot;int g_test;main.cppint _tmain(int argc, _TCHAR* argv[]){    g_test=2;    std::cout&lt;&lt;g_test;    return 0;}</code></pre><p>提示错误，因为此时main中不能调用到g_test。<br>1&gt;d:\microsoft visual studio 9.0\projects\testcpp\testcpp\testcpp.cpp(25) : error C2065: “g_test”: 未声明的标识符<br>1&gt;d:\microsoft visual studio 9.0\projects\testcpp\testcpp\testcpp.cpp(26) : error C2065: “g_test”: 未声明的标识符</p><p>（2）有extern声明，无变量定义。</p><pre><code>stdafx.hextern int g_test;main.cppint _tmain(int argc, _TCHAR* argv[]){    g_test=2;    std::cout&lt;&lt;g_test;    return 0;}</code></pre><p>提示错误，因为extern只是声明，并没有定义，也就没有空间的分配，而这时一个链接错误，编译的时候没办法发现。<br>1&gt;TestCpp.obj : error LNK2001: 无法解析的外部符号 “int g_test” (?g_test@@3HA)<br>1&gt;D:\Microsoft Visual Studio 9.0\Projects\TestCpp\Debug\TestCpp.exe : fatal error LNK1120: 1 个无法解析的外部命令</p><p>（3）有extern声明，也有变量定义。</p><pre><code>stdafx.cpp#include &quot;stdafx.h&quot;int g_test;stdafx.hextern int g_test;main.cppint _tmain(int argc, _TCHAR* argv[]){    g_test=2;    std::cout&lt;&lt;g_test;    return 0;}</code></pre><p>程序执行正常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[toc]&lt;/p&gt;
&lt;h1 id=&quot;首先-明白-这个单词-是什么意思？&quot;&gt;&lt;a href=&quot;#首先-明白-这个单词-是什么意思？&quot; class=&quot;headerlink&quot; title=&quot;首先 明白 这个单词 是什么意思？&quot;&gt;&lt;/a&gt;首先 明白 这个单词 是什么意思？&lt;/h1
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>static关键字</title>
    <link href="http://yoursite.com/2019/09/08/static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/09/08/static关键字/</id>
    <published>2019-09-08T04:57:09.000Z</published>
    <updated>2019-09-08T06:59:10.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h1><ol><li>在全局变量前面，加上关键字 static  ，该变量就成为一个静态全局变量<br>特点：</li><li>1 在全局数据区分配内存</li><li>2 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值 是随机的，除非它被显式初始化）</li><li>3 <strong>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见。</strong></li></ol><p>理解： 避免变量 命名冲突，和其他文件中变量相撞。</p><pre><code>//Example 2//File1#include &lt;iostream.h&gt;void fn();static int n; //定义静态全局变量void main(){ 　　n=20; 　　cout&lt;&lt;n&lt;&lt;endl; 　　fn();}//File2#include &lt;iostream.h&gt;extern int n;void fn(){　　 n++; 　　cout&lt;&lt;n&lt;&lt;endl;}</code></pre><p>编译并运行Example 2，您就会发现上述代码可以分别通过编译，但运行时出现错误。试着将 “static int n; //定义静态全局变量”改为 “int n; //定义全局变量”<br>再次编译运行程序，细心体会“全局变量”和”静态全局变量”的区别。</p><h1 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h1><p>特点：</p><ol><li>静态局部变量 在全局数据区分配内存</li><li>静态局部变量在程序执行到该对象的声明处时，被第一次初始化，即 以后的函数调用不在进行初始化。</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0</li><li>会始终驻留在 全局数据区，直到程序运行结束，但其作用域为局部作用域，当定义它的函数或者语句块结束时，其作用域随之结束。</li></ol><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。 </p><p>理解：静态全局变量 维护 比 静态局部变量维护开销大?<br>static 默认进行初始化为0，并且数据是放在全局数据区中的。两次函数调用就可以对同一个变量进行操作。</p><h1 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h1><ol><li>只能在声明它的文件中可用，其他文件不能被使用 ，从而避免命名冲突</li></ol><h1 id="类中的static-关键字"><a href="#类中的static-关键字" class="headerlink" title="类中的static 关键字"></a>类中的static 关键字</h1><h2 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h2><p>非静态数据成员，会存在多份拷贝，<br>静态数据成员，会存在一份拷贝，由该类型的所有对象共享访问。所以静态成员的值对每个对象都是一样的，它的值可以更新，</p><p><strong><em>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。</em></strong></p><p> 静态数据成员和普通数据成员一样遵从public,protected,private访问规则； </p><p><strong><em>实现信息隐藏</em></strong>，<strong><em>静态数据成员可以是private成员，而全局变量不可以</em></strong></p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>普通函数拥有this 指针 会指向对象本身、<br>但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此不具有this 指针。</p><p>从而更进一步说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其余的<strong>静态成员函数</strong>。</p><pre><code>#include &lt;iostream.h&gt;class Myclass{public: 　　Myclass(int a,int b,int c); 　　static void GetSum();/声明静态成员函数private: 　　int a,b,c;　　 static int Sum;//声明静态数据成员};int Myclass::Sum=0;//定义并初始化静态数据成员Myclass::Myclass(int a,int b,int c){ 　　this-&gt;a=a; 　　this-&gt;b=b; 　　this-&gt;c=c; 　　Sum+=a+b+c; //非静态成员函数可以访问静态数据成员}void Myclass::GetSum() //静态成员函数的实现{　　// cout&lt;&lt;a&lt;&lt;endl; //错误代码，a是非静态数据成员 　　cout&lt;&lt;&quot;Sum=&quot;&lt;&lt;Sum&lt;&lt;endl;}void main(){ 　　Myclass M(1,2,3); 　　M.GetSum(); 　　Myclass N(4,5,6); 　　N.GetSum(); 　　Myclass::GetSum();}</code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>非静态成员函数可以任意访问静态成员函数和静态数据成员。</li><li>静态成员函数不能访问非静态成员函数和非静态数据成员。（因为没有this 指针）</li><li>由于没有this 指针的额外开销，静态成员函数与类的全局函数相比速度会有少许的增长。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;静态全局变量&quot;&gt;&lt;a href=&quot;#静态全局变量&quot; class=&quot;headerlink&quot; title=&quot;静态全局变量&quot;&gt;&lt;/a&gt;静态全局变量&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在全局变量前面，加上关键字 static  ，该变量就成为一个静态全局变量&lt;br&gt;特点：&lt;/li
      
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2019/09/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/08/单例模式/</id>
    <published>2019-09-08T04:55:22.000Z</published>
    <updated>2019-09-08T06:59:48.404Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">class singleton&#123;</span><br><span class="line">private:</span><br><span class="line">    static volatile singleton *p;</span><br><span class="line">    static pthread_mutex_t mtx;</span><br><span class="line">    singleton()&#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    static singleton * getInstance();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">singleton * singleton::p = NULL;</span><br><span class="line">pthread_mutex_t singleton::mtx;</span><br><span class="line"></span><br><span class="line">singleton * singleton::getInstance()&#123;</span><br><span class="line">    if (p == NULL)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mtx);</span><br><span class="line">        if (p == NULL)  p = new singleton;</span><br><span class="line">        pthread_mutex_unlock(&amp;mtx);</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    singleton * ptr = singleton::getInstance();</span><br><span class="line">    singleton * ptr1 = singleton::getInstance();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>git子模块</title>
    <link href="http://yoursite.com/2019/09/08/git%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/09/08/git子模块/</id>
    <published>2019-09-08T04:44:09.000Z</published>
    <updated>2019-09-08T06:58:49.590Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97</a></p><pre><code>git submodule init ;git submodule update;git checkout master ; git submodule foreach git checkout master ; git pull ; git submodule foreach git pull</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://git-sc
      
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>article title</title>
    <link href="http://yoursite.com/2019/09/08/article-title/"/>
    <id>http://yoursite.com/2019/09/08/article-title/</id>
    <published>2019-09-08T04:22:18.000Z</published>
    <updated>2019-09-08T04:22:18.418Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
